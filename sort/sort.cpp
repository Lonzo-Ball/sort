#include <iostream>
#include <stdlib.h>
#include <vector>

void swap(int* x,int* y)
{
	int t = *x;
	*x = *y;
	*y = t;
}

//1. 直接插入排序
//时间复杂度：平均O(N^2) 最好O(N) 最坏O(N^2)
//稳定性：稳定
void InsertSort(int a[],int n)
{
	for(int i = 1;i < n;++i){
		int EndIndex = i;
		while(EndIndex > 0 && a[EndIndex] < a[EndIndex-1]){
			swap(&a[EndIndex],&a[EndIndex-1]);
			EndIndex--;	
		}
	}
}
//2. 希尔排序
//时间复杂度：平均O(N^1.3) 最好O(N) 最坏O(N^2)
//稳定性：不稳定
void ShellSort(int *a,int n)
{
	for(int gap = n/2;gap > 0;gap /= 2){
	for(int i = gap;i < n;++i){
		int end = i;
		while(end > gap-1 && a[end] < a[end-gap]){
			swap(&a[end],&a[end-1]);
			end -= gap;
		}
	}
	}
}

//3. 选择排序
//时间复杂度：O(N^2)
//稳定性：不稳定
void SelectSort(int *a,int n)
{
	int begin = 0,end = n-1;
	while(begin < end){
		int min = begin,max = begin;  //这两个记录值不能放到外面
		for(int i = begin;i <= end;++i)
		{
			if(a[min] > a[i])
				min = i;
			if(a[max] < a[i])
				max = i;
		}

		swap(&a[begin],&a[min]);
		if(begin == max)
			max = min;
		swap(&a[end],&a[max]);

		++begin;
		--end;
	}
}
//4. 堆排序
//时间复杂度：O(N*lgN)
//稳定性：不稳定
void AdjuestDown(int *a,int root,int n)
{
	int parent = root;
	int child = 2*parent+1;
	while(child < n){
		if(child+1 < n && a[child] < a[child+1])
			child += 1;

		if(a[parent] < a[child])
		{
			swap(&a[parent],&a[child]);

			parent = child;
			child = 2*parent+1;
		}
		else
			break;
	}
}
void HeapSort(int *a,int n)
{
	//1. 建大堆
	for(int i = n-1-1/2;i >= 0;--i){
		AdjuestDown(a,i,n);
	}	

	//2. 堆排序
	for(int i = n-1;i > 0;--i){
		swap(&a[0],&a[i]);
		AdjuestDown(a,0,i);
	}
}

//5. 冒泡排序
//时间复杂度：O(N^2) O(N) O(N^2)
//稳定性：稳定
void BubbleSort(int *a,int n)
{
	int border = n-1;  //一趟循环中可能需要交换的元素的边界
	for(;border > 0;){
		int flag = 0;
		int end = border;
		int EndChangeIndex;
		for(int j = 0;j < end;++j){
			if(a[j] > a[j+1])
			{
				swap(&a[j],&a[j+1]);
				flag = 1;

				EndChangeIndex = j;
			}
		}

		if(flag == 0)
			break;	

		border =  EndChangeIndex;
	}
}
//6. 快速排序
//时间复杂度：O(N*lgN) O(N*lgN) O(n^2) 空间复杂度：O(lgN)
//稳定性：不稳定
int partsort(int *a,int begin,int end)
{
	//1. 挖坑法
	#if 0
	int key = a[end];
	while(begin < end)
	{
		while(begin < end && a[begin] <= key){
			++begin;
		}
		a[end] = a[begin];

		while(begin < end && a[end] >= key){
			--end;
		}
		a[begin] = a[end];
	}

	a[begin] = key;
	return begin;
	#endif

	//2. 左右指针法
	#if 0
	int key = a[end];
	int endindex = end;
	while(begin < end)
	{
		while(begin < end && a[begin] <= key){
			++begin;
		}
		while(begin < end && a[end] >= key){
			--end;
		}

		swap(&a[begin],&a[end]);
	}	
	swap(&a[begin],&a[endindex]);
	return begin;
	#endif

	//3. 前后指针法
	int key = a[end];
	int prev = begin - 1, cur = begin;
	while (cur < end)
	{
		if (a[cur] < key && ++prev != cur)
			swap(&a[cur],&a[prev]);

		++cur;
	}
	swap(&a[++prev],&a[end]);
	return prev;
}
void _QuickSort(int *a,int begin,int end)
{
	if(begin < end)
	{
		int mid = partsort(a,begin,end);
		
		_QuickSort(a,begin,mid-1);  //[begin,mid-1] [mid+1,end] mid位置已经是合适的那个值了
		_QuickSort(a,mid+1,end);
	}
}
void QuickSort(int *a,int n)
{
	int begin = 0;
	int end = n-1;

	_QuickSort(a,begin,end);
}

//7. 归并排序
void MergeArray(int *a,int begin,int mid,int end)
{
	//[begin,mid] [mid+1,end]
	std::vector<int> v;
	int i = begin;
	int j = mid +1;
	while(i <= mid && j <= end)
	{
		if(a[i] <= a[j])
		{
			v.push_back(a[i]);
			++i;
		}
		if(a[i] > a[j])
		{
			v.push_back(a[j]);
			++j;
		}
	}
	
	while(i <= mid){
		v.push_back(a[i]);
		++i;
	}
	while(j <= end){
		v.push_back(a[j]);
		++j;
	}

	int index = begin;
	for(int i = 0;i < v.size();++i){
		a[index] = v[i];
		++index;
	}	
}
void _MergeSort(int *a,int begin,int end)
{
	if(begin < end)
	{
		int mid = begin + (end-begin)/2;  //[begin,mid] [mid+1,end]
		_MergeSort(a,begin,mid);
		_MergeSort(a,mid+1,end);

		MergeArray(a,begin,mid,end);		
	}
}
void MergeSort(int *a,int n)
{
	_MergeSort(a,0,n-1);	
}

int main(){
	int a[] = {89,-11,99,89,-11,99,-34,-78,888,-5643,1023,-9,0,89,-11,99,89,-11,99,-34,-78,888,-5643,1023,-9,0,23,89,-11,99,89,-11,99,-34,-78,888,-5643,1023,-9,0,23,1000,9,-23,-88,-76,-34,887,-9765,90,80,80,76,0,860,-34,-78,888,-5643,1023,-9,0,23,89,-11,99,-34,-78,888,-5643,1023,-9,0,23,1000,9,-23,-88,89,-11,99,-34,-78,888,-5643,1023,-9,0,23,1000,9,-23,-88,-76,-34,887,-9765,90,80,80,76,0,860,-76,-34,887,-9765,90,80,80,76,0,860,1000,9,-23,-88,-76,-34,887,89,-11,99,-34,-78,888,-5643,1023,-9,0,23,1000,9,-23,-88,-76,-34,887,-9765,90,80,80,76,0,860,89,-11,99,-34,-78,888,-5643,1023,-9,0,23,1000,9,-23,-88,-76,-34,887,-9765,90,80,80,76,0,860,-9765,90,80,80,76,0,860,1000,9,-23,-88,-76,-34,887,-9765,90,80,80,76,0,860,-34,-78,888,-5643,1023,-9,0,23,89,-11,99,89,-11,99,-34,-78,888,-5643,1023,-9,0,23,1000,9,-23,-88,-76,-34,887,-9765,90,80,80,76,0,860,-34,-78,888,-5643,1023,-9,0,23,89,-11,99,-34,-78,888,-5643,1023,-9,0,23,1000,9,-23,-88,89,-11,99,-34,-78,888,-5643,1023,-9,0,23,1000,9,-23,-88,-76,-34,887,-9765,90,80,80,76,0,860,-76,-34,887,-9765,90,80,80,76,0,860,1000,9,-23,-88,-76,-34,887,89,-11,99,-34,-78,888,-5643,1023,-9,0,23,1000,9,-23,-88,-76,-34,887,-9765,90,80,80,76,0,860,89,-11,99,-34,-78,888,-5643,1023,-9,0,23,1000,9,-23,-88,-76,-34,887,-9765,90,80,80,76,0,860,-9765,90,80,80,76,0,860,89,-11,99,-34,-78,888,-5643,1023,-9,0,23,1000,9,-23,-88,89,-11,99,-34,-78,888,-5643,1023,-9,0,23,1000,9,-23,-88,-76,-34,887,-9765,90,80,80,76,0,860,-76,-34,887,-9765,90,80,80,76,0,860,1000,9,-23,-88,-76,-34,887,89,-11,99,-34,-78,888,-5643,1023,-9,0,23,1000,9,-23,-88,-76,-34,887,-9765,90,80,80,76,0,860,89,-11,99,-34,-78,888,-5643,1023,-9,0,23,1000,9,-23,-88,-76,-34,887,-9765,90,80,80,76,0,860,-9765,90,80,80,76,0,860,23,89,-11,99,89,-11,99,-34,-78,888,-5643,1023,-9,0,23,1000,9,-23,-88,-76,-34,887,-9765,90,80,80,76,0,860,-34,-78,888,-5643,1023,-9,0,23,89,-11,99,-34,-78,888,-5643,1023,-9,0,23,1000,9,-23,-88,89,-11,99,-34,-78,888,-5643,1023,-9,0,23,1000,9,-23,-88,-76,-34,887,-9765,90,80,80,76,0,860,-76,-34,887,-9765,90,80,80,76,0,860,1000,9,-23,-88,-76,-34,887,89,-11,99,-34,-78,888,-5643,1023,-9,0,23,1000,9,-23,-88,-76,-34,887,-9765,90,80,80,76,0,860,89,-11,99,-34,-78,888,-5643,1023,-9,0,23,1000,9,-23,-88,-76,-34,887,-9765,90,80,80,76,0,860,-9765,90,80,80,76,0,860,1000,9,-23,-88,-76,-34,887,-9765,90,80,80,76,0,860,-34,-78,888,-5643,1023,-9,0,23,89,-11,99,89,-11,99,-34,-78,888,-5643,1023,-9,0,23,1000,9,-23,-88,-76,-34,887,-9765,90,80,80,76,0,860,-34,-78,888,-5643,1023,-9,0,23,89,-11,99,-34,-78,888,-5643,1023,-9,0,23,1000,9,-23,-88,89,-11,99,-34,-78,888,-5643,1023,-9,0,23,1000,9,-23,-88,-76,-34,887,-9765,90,80,80,76,0,860,-76,-34,887,-9765,90,80,80,76,0,860,1000,9,-23,-88,-76,-34,887,89,-11,99,-34,-78,888,-5643,1023,-9,0,23,1000,9,-23,-88,-76,-34,887,-9765,90,80,80,76,0,860,89,-11,99,-34,-78,888,-5643,1023,-9,0,23,1000,9,-23,-88,-76,-34,887,-9765,90,80,80,76,0,860,-9765,90,80,80,76,0,860,89,-11,99,-34,-78,888,-5643,1023,-9,0,23,1000,9,-23,-88,89,-11,99,-34,-78,888,-5643,1023,-9,0,23,1000,9,-23,-88,-76,-34,887,-9765,90,80,80,76,0,860,-76,-34,887,-9765,90,80,80,76,0,860,1000,9,-23,-88,-76,-34,887,89,-11,99,-34,-78,888,-5643,1023,-9,0,23,1000,9,-23,-88,-76,-34,887,-9765,90,80,80,76,0,860,89,-11,99,-34,-78,888,-5643,1023,-9,0,23,1000,9,-23,-88,-76,-34,887,-9765,90,80,80,76,0,860,-9765,90,80,80,76,0,860};
	int N = sizeof(a)/sizeof(a[0]);
	
	//InsertSort(a,N);
	//ShellSort(a,N);
	
	//SelectSort(a,N);	 
	//HeapSort(a,N);
	
	//BubbleSort(a,N);
	//QuickSort(a,N);

	MergeSort(a,N);
	for(int i = 0;i < N-1;++i){
		if(a[i] <= a[i+1])
			std::cout<< a[i] << "  ";
		else
			std::cout<< "sort error!" <<std::endl;
	}
	std::cout<< a[N-1] <<std::endl;
	return 0;
}
